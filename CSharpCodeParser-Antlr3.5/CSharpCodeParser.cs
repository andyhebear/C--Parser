//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 CSharpCode.g 2013-06-30 23:01:31

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

namespace  Gplusnasite.CSharpParser 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class CSharpCodeParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COMMENT", "DEFAULT_VALUE", "ESC_SEQ", "HEX_DIGIT", "NAME", "SPACE", "STRING", "UNICODE_ESC", "'('", "')'", "','", "'.'", "':'", "';'", "'='", "'class'", "'private'", "'protected'", "'public'", "'using'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int COMMENT=4;
	public const int DEFAULT_VALUE=5;
	public const int ESC_SEQ=6;
	public const int HEX_DIGIT=7;
	public const int NAME=8;
	public const int SPACE=9;
	public const int STRING=10;
	public const int UNICODE_ESC=11;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public CSharpCodeParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CSharpCodeParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return CSharpCodeParser.tokenNames; } }
	public override string GrammarFileName { get { return "CSharpCode.g"; } }


	    public AccessType Accessor = AccessType.Private;


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_using_namespace() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_using_namespace() {}
	// $ANTLR start "using_namespace"
	// CSharpCode.g:53:1: fragment using_namespace returns [string result] : NAME ;
	[GrammarRule("using_namespace")]
	private string using_namespace()
	{
		EnterRule_using_namespace();
		EnterRule("using_namespace", 1);
		TraceIn("using_namespace", 1);
	    string result = default(string);


	    IToken NAME1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "using_namespace");
		DebugLocation(53, 0);
		try
		{
			// CSharpCode.g:54:3: ( NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:54:3: NAME
			{
			DebugLocation(54, 3);
			NAME1=(IToken)Match(input,NAME,Follow._NAME_in_using_namespace352); 
			DebugLocation(55, 1);

			    result = (NAME1!=null?NAME1.Text:default(string));


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("using_namespace", 1);
			LeaveRule("using_namespace", 1);
			LeaveRule_using_namespace();
	    }
	 	DebugLocation(58, 0);
		} finally { DebugExitRule(GrammarFileName, "using_namespace"); }
		return result;

	}
	// $ANTLR end "using_namespace"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_using_namespaces() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_using_namespaces() {}
	// $ANTLR start "using_namespaces"
	// CSharpCode.g:60:1: using_namespaces returns [Namespaces result] : ( 'using' SPACE (namespace1= using_namespace ) ( '.' (namespace2= using_namespace ) )* ';' ) ;
	[GrammarRule("using_namespaces")]
	private Namespaces using_namespaces()
	{
		EnterRule_using_namespaces();
		EnterRule("using_namespaces", 2);
		TraceIn("using_namespaces", 2);
	    Namespaces result = default(Namespaces);


	    string namespace1 = default(string);
	    string namespace2 = default(string);


	            result = new Namespaces();
	        
		try { DebugEnterRule(GrammarFileName, "using_namespaces");
		DebugLocation(60, 0);
		try
		{
			// CSharpCode.g:65:5: ( ( 'using' SPACE (namespace1= using_namespace ) ( '.' (namespace2= using_namespace ) )* ';' ) )
			DebugEnterAlt(1);
			// CSharpCode.g:65:7: ( 'using' SPACE (namespace1= using_namespace ) ( '.' (namespace2= using_namespace ) )* ';' )
			{
			DebugLocation(65, 7);
			// CSharpCode.g:65:7: ( 'using' SPACE (namespace1= using_namespace ) ( '.' (namespace2= using_namespace ) )* ';' )
			DebugEnterAlt(1);
			// CSharpCode.g:65:8: 'using' SPACE (namespace1= using_namespace ) ( '.' (namespace2= using_namespace ) )* ';'
			{
			DebugLocation(65, 8);
			Match(input,23,Follow._23_in_using_namespaces385); 
			DebugLocation(65, 16);
			Match(input,SPACE,Follow._SPACE_in_using_namespaces387); 
			DebugLocation(65, 22);
			// CSharpCode.g:65:22: (namespace1= using_namespace )
			DebugEnterAlt(1);
			// CSharpCode.g:65:23: namespace1= using_namespace
			{
			DebugLocation(65, 34);
			PushFollow(Follow._using_namespace_in_using_namespaces394);
			namespace1=using_namespace();
			PopFollow();


			}

			DebugLocation(66, 5);

			        result.Names.Add(namespace1);
			        result.FullName += namespace1;
			    
			DebugLocation(70, 5);
			// CSharpCode.g:70:5: ( '.' (namespace2= using_namespace ) )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_1 = input.LA(1);

				if ((LA1_1==15))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// CSharpCode.g:70:6: '.' (namespace2= using_namespace )
					{
					DebugLocation(70, 6);
					Match(input,15,Follow._15_in_using_namespaces408); 
					DebugLocation(70, 10);
					// CSharpCode.g:70:10: (namespace2= using_namespace )
					DebugEnterAlt(1);
					// CSharpCode.g:70:11: namespace2= using_namespace
					{
					DebugLocation(70, 22);
					PushFollow(Follow._using_namespace_in_using_namespaces415);
					namespace2=using_namespace();
					PopFollow();


					}

					DebugLocation(71, 5);

					        result.Names.Add(namespace2);
					        result.FullName += ("." + namespace2);
					    

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(75, 8);
			Match(input,17,Follow._17_in_using_namespaces431); 

			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("using_namespaces", 2);
			LeaveRule("using_namespaces", 2);
			LeaveRule_using_namespaces();
	    }
	 	DebugLocation(76, 0);
		} finally { DebugExitRule(GrammarFileName, "using_namespaces"); }
		return result;

	}
	// $ANTLR end "using_namespaces"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_access_type() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_access_type() {}
	// $ANTLR start "access_type"
	// CSharpCode.g:78:1: access_type returns [AccessType result] : ( ( 'public' ':' ) | ( 'protected' ':' ) | ( 'private' ':' ) );
	[GrammarRule("access_type")]
	private AccessType access_type()
	{
		EnterRule_access_type();
		EnterRule("access_type", 3);
		TraceIn("access_type", 3);
	    AccessType result = default(AccessType);


		try { DebugEnterRule(GrammarFileName, "access_type");
		DebugLocation(78, 4);
		try
		{
			// CSharpCode.g:79:5: ( ( 'public' ':' ) | ( 'protected' ':' ) | ( 'private' ':' ) )
			int alt2=3;
			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
			switch (input.LA(1))
			{
			case 22:
				{
				alt2 = 1;
				}
				break;
			case 21:
				{
				alt2 = 2;
				}
				break;
			case 20:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:80:5: ( 'public' ':' )
				{
				DebugLocation(80, 5);
				// CSharpCode.g:80:5: ( 'public' ':' )
				DebugEnterAlt(1);
				// CSharpCode.g:80:6: 'public' ':'
				{
				DebugLocation(80, 6);
				Match(input,22,Follow._22_in_access_type454); 
				DebugLocation(80, 15);
				Match(input,16,Follow._16_in_access_type456); 

				}

				DebugLocation(81, 5);

				        Accessor = AccessType.Public;
				        result = AccessType.Public;
				    

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CSharpCode.g:85:6: ( 'protected' ':' )
				{
				DebugLocation(85, 6);
				// CSharpCode.g:85:6: ( 'protected' ':' )
				DebugEnterAlt(1);
				// CSharpCode.g:85:7: 'protected' ':'
				{
				DebugLocation(85, 7);
				Match(input,21,Follow._21_in_access_type471); 
				DebugLocation(85, 19);
				Match(input,16,Follow._16_in_access_type473); 

				}

				DebugLocation(86, 5);

				        Accessor = AccessType.Protected;
				        result = AccessType.Protected;
				    

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// CSharpCode.g:90:6: ( 'private' ':' )
				{
				DebugLocation(90, 6);
				// CSharpCode.g:90:6: ( 'private' ':' )
				DebugEnterAlt(1);
				// CSharpCode.g:90:7: 'private' ':'
				{
				DebugLocation(90, 7);
				Match(input,20,Follow._20_in_access_type488); 
				DebugLocation(90, 17);
				Match(input,16,Follow._16_in_access_type490); 

				}

				DebugLocation(91, 5);

				        Accessor = AccessType.Private;
				        result = AccessType.Private;
				    

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("access_type", 3);
			LeaveRule("access_type", 3);
			LeaveRule_access_type();
	    }
	 	DebugLocation(95, 4);
		} finally { DebugExitRule(GrammarFileName, "access_type"); }
		return result;

	}
	// $ANTLR end "access_type"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_variable_value() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_variable_value() {}
	// $ANTLR start "variable_value"
	// CSharpCode.g:102:1: variable_value : '=' ( (~ ( ';' ) )+ ) ';' ;
	[GrammarRule("variable_value")]
	private void variable_value()
	{
		EnterRule_variable_value();
		EnterRule("variable_value", 4);
		TraceIn("variable_value", 4);
		try { DebugEnterRule(GrammarFileName, "variable_value");
		DebugLocation(102, 4);
		try
		{
			// CSharpCode.g:103:5: ( '=' ( (~ ( ';' ) )+ ) ';' )
			DebugEnterAlt(1);
			// CSharpCode.g:103:6: '=' ( (~ ( ';' ) )+ ) ';'
			{
			DebugLocation(103, 6);
			Match(input,18,Follow._18_in_variable_value567); 
			DebugLocation(103, 10);
			// CSharpCode.g:103:10: ( (~ ( ';' ) )+ )
			DebugEnterAlt(1);
			// CSharpCode.g:103:11: (~ ( ';' ) )+
			{
			DebugLocation(103, 11);
			// CSharpCode.g:103:11: (~ ( ';' ) )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, decisionCanBacktrack[3]);
				int LA3_1 = input.LA(1);

				if (((LA3_1>=COMMENT && LA3_1<=16)||(LA3_1>=18 && LA3_1<=25)))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// CSharpCode.g:
					{
					DebugLocation(103, 11);
					if ((input.LA(1)>=COMMENT && input.LA(1)<=16)||(input.LA(1)>=18 && input.LA(1)<=25))
					{
						input.Consume();
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			DebugLocation(103, 20);
			Match(input,17,Follow._17_in_variable_value577); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variable_value", 4);
			LeaveRule("variable_value", 4);
			LeaveRule_variable_value();
	    }
	 	DebugLocation(104, 4);
		} finally { DebugExitRule(GrammarFileName, "variable_value"); }
		return;

	}
	// $ANTLR end "variable_value"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_variable() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_variable() {}
	// $ANTLR start "variable"
	// CSharpCode.g:106:1: variable returns [Variable result] : ( ( access_type )? (type= NAME ) SPACE (name= NAME ) ';' ) ;
	[GrammarRule("variable")]
	private Variable variable()
	{
		EnterRule_variable();
		EnterRule("variable", 5);
		TraceIn("variable", 5);
	    Variable result = default(Variable);


	    IToken type = default(IToken);
	    IToken name = default(IToken);


	            result = new Variable();
	        
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(106, 4);
		try
		{
			// CSharpCode.g:111:5: ( ( ( access_type )? (type= NAME ) SPACE (name= NAME ) ';' ) )
			DebugEnterAlt(1);
			// CSharpCode.g:111:6: ( ( access_type )? (type= NAME ) SPACE (name= NAME ) ';' )
			{
			DebugLocation(111, 6);
			// CSharpCode.g:111:6: ( ( access_type )? (type= NAME ) SPACE (name= NAME ) ';' )
			DebugEnterAlt(1);
			// CSharpCode.g:111:7: ( access_type )? (type= NAME ) SPACE (name= NAME ) ';'
			{
			DebugLocation(111, 7);
			// CSharpCode.g:111:7: ( access_type )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_1 = input.LA(1);

			if (((LA4_1>=20 && LA4_1<=22)))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:111:7: access_type
				{
				DebugLocation(111, 7);
				PushFollow(Follow._access_type_in_variable619);
				access_type();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(111, 20);
			// CSharpCode.g:111:20: (type= NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:111:21: type= NAME
			{
			DebugLocation(111, 26);
			type=(IToken)Match(input,NAME,Follow._NAME_in_variable627); 

			}

			DebugLocation(111, 34);
			Match(input,SPACE,Follow._SPACE_in_variable630); 
			DebugLocation(111, 40);
			// CSharpCode.g:111:40: (name= NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:111:41: name= NAME
			{
			DebugLocation(111, 46);
			name=(IToken)Match(input,NAME,Follow._NAME_in_variable637); 

			}

			DebugLocation(111, 54);
			Match(input,17,Follow._17_in_variable640); 

			}

			DebugLocation(112, 5);

			    	result.Accessor = Accessor;
			    	result.Type = (type!=null?type.Text:default(string));
			    	result.Name = (name!=null?name.Text:default(string));
			    

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variable", 5);
			LeaveRule("variable", 5);
			LeaveRule_variable();
	    }
	 	DebugLocation(117, 4);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return result;

	}
	// $ANTLR end "variable"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_parameter() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_parameter() {}
	// $ANTLR start "parameter"
	// CSharpCode.g:119:1: parameter returns [Variable result] : (type= NAME ) SPACE (name= NAME ) ;
	[GrammarRule("parameter")]
	private Variable parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 6);
		TraceIn("parameter", 6);
	    Variable result = default(Variable);


	    IToken type = default(IToken);
	    IToken name = default(IToken);


	            result = new Variable();
	        
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(119, 4);
		try
		{
			// CSharpCode.g:124:5: ( (type= NAME ) SPACE (name= NAME ) )
			DebugEnterAlt(1);
			// CSharpCode.g:124:6: (type= NAME ) SPACE (name= NAME )
			{
			DebugLocation(124, 6);
			// CSharpCode.g:124:6: (type= NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:124:7: type= NAME
			{
			DebugLocation(124, 12);
			type=(IToken)Match(input,NAME,Follow._NAME_in_parameter689); 

			}

			DebugLocation(124, 20);
			Match(input,SPACE,Follow._SPACE_in_parameter692); 
			DebugLocation(124, 26);
			// CSharpCode.g:124:26: (name= NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:124:27: name= NAME
			{
			DebugLocation(124, 32);
			name=(IToken)Match(input,NAME,Follow._NAME_in_parameter699); 

			}

			DebugLocation(125, 5);

			    	result.Accessor = AccessType.None;
			    	result.Type = (type!=null?type.Text:default(string));
			    	result.Name = (name!=null?name.Text:default(string));
			    

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parameter", 6);
			LeaveRule("parameter", 6);
			LeaveRule_parameter();
	    }
	 	DebugLocation(130, 4);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return result;

	}
	// $ANTLR end "parameter"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_parameters() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_parameters() {}
	// $ANTLR start "parameters"
	// CSharpCode.g:132:1: parameters returns [List<Variable> result] : ( (parameter1= parameter ) ( ( SPACE )? ( ',' ( SPACE )? parameter2= parameter ) )* )? ;
	[GrammarRule("parameters")]
	private List<Variable> parameters()
	{
		EnterRule_parameters();
		EnterRule("parameters", 7);
		TraceIn("parameters", 7);
	    List<Variable> result = default(List<Variable>);


	    Variable parameter1 = default(Variable);
	    Variable parameter2 = default(Variable);


	            result = new List<Variable>();
	        
		try { DebugEnterRule(GrammarFileName, "parameters");
		DebugLocation(132, 4);
		try
		{
			// CSharpCode.g:137:5: ( ( (parameter1= parameter ) ( ( SPACE )? ( ',' ( SPACE )? parameter2= parameter ) )* )? )
			DebugEnterAlt(1);
			// CSharpCode.g:137:6: ( (parameter1= parameter ) ( ( SPACE )? ( ',' ( SPACE )? parameter2= parameter ) )* )?
			{
			DebugLocation(137, 6);
			// CSharpCode.g:137:6: ( (parameter1= parameter ) ( ( SPACE )? ( ',' ( SPACE )? parameter2= parameter ) )* )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, decisionCanBacktrack[8]);
			int LA8_1 = input.LA(1);

			if ((LA8_1==NAME))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:137:7: (parameter1= parameter ) ( ( SPACE )? ( ',' ( SPACE )? parameter2= parameter ) )*
				{
				DebugLocation(137, 7);
				// CSharpCode.g:137:7: (parameter1= parameter )
				DebugEnterAlt(1);
				// CSharpCode.g:137:8: parameter1= parameter
				{
				DebugLocation(137, 19);
				PushFollow(Follow._parameter_in_parameters749);
				parameter1=parameter();
				PopFollow();


				}

				DebugLocation(138, 5);

				    	if (parameter1 != null)
				    	{
				    	    result.Add(parameter1);
				    	}
				    
				DebugLocation(144, 6);
				// CSharpCode.g:144:6: ( ( SPACE )? ( ',' ( SPACE )? parameter2= parameter ) )*
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, decisionCanBacktrack[7]);
					int LA7_1 = input.LA(1);

					if ((LA7_1==SPACE))
					{
						int LA7_2 = input.LA(2);

						if ((LA7_2==14))
						{
							alt7 = 1;
						}


					}
					else if ((LA7_1==14))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch ( alt7 )
					{
					case 1:
						DebugEnterAlt(1);
						// CSharpCode.g:144:7: ( SPACE )? ( ',' ( SPACE )? parameter2= parameter )
						{
						DebugLocation(144, 7);
						// CSharpCode.g:144:7: ( SPACE )?
						int alt5=2;
						try { DebugEnterSubRule(5);
						try { DebugEnterDecision(5, decisionCanBacktrack[5]);
						int LA5_1 = input.LA(1);

						if ((LA5_1==SPACE))
						{
							alt5 = 1;
						}
						} finally { DebugExitDecision(5); }
						switch (alt5)
						{
						case 1:
							DebugEnterAlt(1);
							// CSharpCode.g:144:7: SPACE
							{
							DebugLocation(144, 7);
							Match(input,SPACE,Follow._SPACE_in_parameters764); 

							}
							break;

						}
						} finally { DebugExitSubRule(5); }

						DebugLocation(144, 14);
						// CSharpCode.g:144:14: ( ',' ( SPACE )? parameter2= parameter )
						DebugEnterAlt(1);
						// CSharpCode.g:144:15: ',' ( SPACE )? parameter2= parameter
						{
						DebugLocation(144, 15);
						Match(input,14,Follow._14_in_parameters768); 
						DebugLocation(144, 19);
						// CSharpCode.g:144:19: ( SPACE )?
						int alt6=2;
						try { DebugEnterSubRule(6);
						try { DebugEnterDecision(6, decisionCanBacktrack[6]);
						int LA6_1 = input.LA(1);

						if ((LA6_1==SPACE))
						{
							alt6 = 1;
						}
						} finally { DebugExitDecision(6); }
						switch (alt6)
						{
						case 1:
							DebugEnterAlt(1);
							// CSharpCode.g:144:19: SPACE
							{
							DebugLocation(144, 19);
							Match(input,SPACE,Follow._SPACE_in_parameters770); 

							}
							break;

						}
						} finally { DebugExitSubRule(6); }

						DebugLocation(144, 37);
						PushFollow(Follow._parameter_in_parameters777);
						parameter2=parameter();
						PopFollow();


						}

						DebugLocation(145, 6);

						    	if (parameter2 != null)
						    	{
						    	    result.Add(parameter2);
						    	}
						    

						}
						break;

					default:
						goto loop7;
					}
				}

				loop7:
					;

				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parameters", 7);
			LeaveRule("parameters", 7);
			LeaveRule_parameters();
	    }
	 	DebugLocation(153, 4);
		} finally { DebugExitRule(GrammarFileName, "parameters"); }
		return result;

	}
	// $ANTLR end "parameters"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_function_value() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_function_value() {}
	// $ANTLR start "function_value"
	// CSharpCode.g:155:1: function_value : '{' ( options {greedy=false; } : . )* '}' ;
	[GrammarRule("function_value")]
	private void function_value()
	{
		EnterRule_function_value();
		EnterRule("function_value", 8);
		TraceIn("function_value", 8);
		try { DebugEnterRule(GrammarFileName, "function_value");
		DebugLocation(155, 4);
		try
		{
			// CSharpCode.g:156:5: ( '{' ( options {greedy=false; } : . )* '}' )
			DebugEnterAlt(1);
			// CSharpCode.g:157:5: '{' ( options {greedy=false; } : . )* '}'
			{
			DebugLocation(157, 5);
			Match(input,24,Follow._24_in_function_value826); 
			DebugLocation(157, 9);
			// CSharpCode.g:157:9: ( options {greedy=false; } : . )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, decisionCanBacktrack[9]);
				try
				{
					alt9 = dfa9.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// CSharpCode.g:157:37: .
					{
					DebugLocation(157, 37);
					MatchAny(input); 

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(157, 42);
			Match(input,25,Follow._25_in_function_value844); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("function_value", 8);
			LeaveRule("function_value", 8);
			LeaveRule_function_value();
	    }
	 	DebugLocation(158, 4);
		} finally { DebugExitRule(GrammarFileName, "function_value"); }
		return;

	}
	// $ANTLR end "function_value"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_function() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_function() {}
	// $ANTLR start "function"
	// CSharpCode.g:160:1: function returns [Function result] : ( access_type )? (return_type= NAME ) SPACE (name= NAME ) '(' ( SPACE )? parameters ( SPACE )? ')' ( ';' | function_value ) ;
	[GrammarRule("function")]
	private Function function()
	{
		EnterRule_function();
		EnterRule("function", 9);
		TraceIn("function", 9);
	    Function result = default(Function);


	    IToken return_type = default(IToken);
	    IToken name = default(IToken);
	    List<Variable> parameters2 = default(List<Variable>);


	            result = new Function();
	        
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(160, 4);
		try
		{
			// CSharpCode.g:165:5: ( ( access_type )? (return_type= NAME ) SPACE (name= NAME ) '(' ( SPACE )? parameters ( SPACE )? ')' ( ';' | function_value ) )
			DebugEnterAlt(1);
			// CSharpCode.g:165:6: ( access_type )? (return_type= NAME ) SPACE (name= NAME ) '(' ( SPACE )? parameters ( SPACE )? ')' ( ';' | function_value )
			{
			DebugLocation(165, 6);
			// CSharpCode.g:165:6: ( access_type )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, decisionCanBacktrack[10]);
			int LA10_1 = input.LA(1);

			if (((LA10_1>=20 && LA10_1<=22)))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:165:6: access_type
				{
				DebugLocation(165, 6);
				PushFollow(Follow._access_type_in_function877);
				access_type();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(165, 19);
			// CSharpCode.g:165:19: (return_type= NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:165:20: return_type= NAME
			{
			DebugLocation(165, 32);
			return_type=(IToken)Match(input,NAME,Follow._NAME_in_function885); 

			}

			DebugLocation(165, 40);
			Match(input,SPACE,Follow._SPACE_in_function888); 
			DebugLocation(165, 46);
			// CSharpCode.g:165:46: (name= NAME )
			DebugEnterAlt(1);
			// CSharpCode.g:165:47: name= NAME
			{
			DebugLocation(165, 52);
			name=(IToken)Match(input,NAME,Follow._NAME_in_function895); 

			}

			DebugLocation(165, 60);
			Match(input,12,Follow._12_in_function898); 
			DebugLocation(165, 64);
			// CSharpCode.g:165:64: ( SPACE )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, decisionCanBacktrack[11]);
			int LA11_1 = input.LA(1);

			if ((LA11_1==SPACE))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:165:64: SPACE
				{
				DebugLocation(165, 64);
				Match(input,SPACE,Follow._SPACE_in_function900); 

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(165, 71);
			PushFollow(Follow._parameters_in_function903);
			parameters2=parameters();
			PopFollow();

			DebugLocation(165, 82);
			// CSharpCode.g:165:82: ( SPACE )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, decisionCanBacktrack[12]);
			int LA12_1 = input.LA(1);

			if ((LA12_1==SPACE))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:165:82: SPACE
				{
				DebugLocation(165, 82);
				Match(input,SPACE,Follow._SPACE_in_function905); 

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(165, 89);
			Match(input,13,Follow._13_in_function908); 
			DebugLocation(165, 93);
			// CSharpCode.g:165:93: ( ';' | function_value )
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, decisionCanBacktrack[13]);
			int LA13_1 = input.LA(1);

			if ((LA13_1==17))
			{
				alt13 = 1;
			}
			else if ((LA13_1==24))
			{
				alt13 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:165:94: ';'
				{
				DebugLocation(165, 94);
				Match(input,17,Follow._17_in_function911); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CSharpCode.g:165:100: function_value
				{
				DebugLocation(165, 100);
				PushFollow(Follow._function_value_in_function915);
				function_value();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(166, 5);

			    	result.Accessor = Accessor;
			    	result.ReturnType = (return_type!=null?return_type.Text:default(string));
			    	result.Name = (name!=null?name.Text:default(string));
			    	result.Parameters = parameters2;    	
			    

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("function", 9);
			LeaveRule("function", 9);
			LeaveRule_function();
	    }
	 	DebugLocation(172, 4);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return result;

	}
	// $ANTLR end "function"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_class() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_class() {}
	// $ANTLR start "class"
	// CSharpCode.g:174:1: class returns [Class result] : ( access_type )? 'class' NAME '{' ( variable | function )* '}' ';' ;
	[GrammarRule("class")]
	private Class @class()
	{
		EnterRule_class();
		EnterRule("class", 10);
		TraceIn("class", 10);
	    Class result = default(Class);


	    IToken NAME3 = default(IToken);
	    Variable variable4 = default(Variable);
	    Function function5 = default(Function);


	            result = new Class();
	        
		try { DebugEnterRule(GrammarFileName, "class");
		DebugLocation(174, 4);
		try
		{
			// CSharpCode.g:179:5: ( ( access_type )? 'class' NAME '{' ( variable | function )* '}' ';' )
			DebugEnterAlt(1);
			// CSharpCode.g:179:6: ( access_type )? 'class' NAME '{' ( variable | function )* '}' ';'
			{
			DebugLocation(179, 6);
			// CSharpCode.g:179:6: ( access_type )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, decisionCanBacktrack[14]);
			int LA14_1 = input.LA(1);

			if (((LA14_1>=20 && LA14_1<=22)))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// CSharpCode.g:179:6: access_type
				{
				DebugLocation(179, 6);
				PushFollow(Follow._access_type_in_class959);
				access_type();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(179, 19);
			Match(input,19,Follow._19_in_class962); 
			DebugLocation(179, 27);
			NAME3=(IToken)Match(input,NAME,Follow._NAME_in_class964); 
			DebugLocation(180, 5);

			        result.Name = (NAME3!=null?NAME3.Text:default(string));
			    
			DebugLocation(183, 5);
			Match(input,24,Follow._24_in_class976); 
			DebugLocation(185, 5);
			// CSharpCode.g:185:5: ( variable | function )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=3;
				try { DebugEnterDecision(15, decisionCanBacktrack[15]);
				switch (input.LA(1))
				{
				case 22:
					{
					int LA15_2 = input.LA(2);

					if ((LA15_2==16))
					{
						int LA15_3 = input.LA(3);

						if ((LA15_3==NAME))
						{
							int LA15_4 = input.LA(4);

							if ((LA15_4==SPACE))
							{
								int LA15_5 = input.LA(5);

								if ((LA15_5==NAME))
								{
									int LA15_6 = input.LA(6);

									if ((LA15_6==17))
									{
										alt15 = 1;
									}
									else if ((LA15_6==12))
									{
										alt15 = 2;
									}


								}


							}


						}


					}


					}
					break;
				case 21:
					{
					int LA15_2 = input.LA(2);

					if ((LA15_2==16))
					{
						int LA15_3 = input.LA(3);

						if ((LA15_3==NAME))
						{
							int LA15_4 = input.LA(4);

							if ((LA15_4==SPACE))
							{
								int LA15_5 = input.LA(5);

								if ((LA15_5==NAME))
								{
									int LA15_6 = input.LA(6);

									if ((LA15_6==17))
									{
										alt15 = 1;
									}
									else if ((LA15_6==12))
									{
										alt15 = 2;
									}


								}


							}


						}


					}


					}
					break;
				case 20:
					{
					int LA15_2 = input.LA(2);

					if ((LA15_2==16))
					{
						int LA15_3 = input.LA(3);

						if ((LA15_3==NAME))
						{
							int LA15_4 = input.LA(4);

							if ((LA15_4==SPACE))
							{
								int LA15_5 = input.LA(5);

								if ((LA15_5==NAME))
								{
									int LA15_6 = input.LA(6);

									if ((LA15_6==17))
									{
										alt15 = 1;
									}
									else if ((LA15_6==12))
									{
										alt15 = 2;
									}


								}


							}


						}


					}


					}
					break;
				case NAME:
					{
					int LA15_2 = input.LA(2);

					if ((LA15_2==SPACE))
					{
						int LA15_3 = input.LA(3);

						if ((LA15_3==NAME))
						{
							int LA15_4 = input.LA(4);

							if ((LA15_4==17))
							{
								alt15 = 1;
							}
							else if ((LA15_4==12))
							{
								alt15 = 2;
							}


						}


					}


					}
					break;
				}

				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// CSharpCode.g:185:6: variable
					{
					DebugLocation(185, 6);
					PushFollow(Follow._variable_in_class988);
					variable4=variable();
					PopFollow();

					DebugLocation(186, 5);

					    	result.Variables.Add(variable4);
					    

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// CSharpCode.g:189:7: function
					{
					DebugLocation(189, 7);
					PushFollow(Follow._function_in_class1002);
					function5=function();
					PopFollow();

					DebugLocation(190, 5);

					    	result.Functions.Add(function5);
					    

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(195, 5);
			Match(input,25,Follow._25_in_class1026); 
			DebugLocation(195, 9);
			Match(input,17,Follow._17_in_class1028); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("class", 10);
			LeaveRule("class", 10);
			LeaveRule_class();
	    }
	 	DebugLocation(196, 4);
		} finally { DebugExitRule(GrammarFileName, "class"); }
		return result;

	}
	// $ANTLR end "class"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_cpp_code() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_cpp_code() {}
	// $ANTLR start "cpp_code"
	// CSharpCode.g:198:1: cpp_code returns [CSharpCode result] : ( using_namespaces | class | variable | function )* ;
	[GrammarRule("cpp_code")]
	private CSharpCode cpp_code()
	{
		EnterRule_cpp_code();
		EnterRule("cpp_code", 11);
		TraceIn("cpp_code", 11);
	    CSharpCode result = default(CSharpCode);


	    Namespaces using_namespaces6 = default(Namespaces);
	    Class class7 = default(Class);
	    Variable variable8 = default(Variable);
	    Function function9 = default(Function);


	            result = new CSharpCode();
	        
		try { DebugEnterRule(GrammarFileName, "cpp_code");
		DebugLocation(198, 4);
		try
		{
			// CSharpCode.g:203:5: ( ( using_namespaces | class | variable | function )* )
			DebugEnterAlt(1);
			// CSharpCode.g:204:5: ( using_namespaces | class | variable | function )*
			{
			DebugLocation(204, 5);
			// CSharpCode.g:204:5: ( using_namespaces | class | variable | function )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=5;
				try { DebugEnterDecision(16, decisionCanBacktrack[16]);
				switch (input.LA(1))
				{
				case 23:
					{
					alt16 = 1;
					}
					break;
				case 22:
					{
					int LA16_2 = input.LA(2);

					if ((LA16_2==16))
					{
						int LA16_3 = input.LA(3);

						if ((LA16_3==19))
						{
							alt16 = 2;
						}
						else if ((LA16_3==NAME))
						{
							int LA16_4 = input.LA(4);

							if ((LA16_4==SPACE))
							{
								int LA16_5 = input.LA(5);

								if ((LA16_5==NAME))
								{
									int LA16_6 = input.LA(6);

									if ((LA16_6==17))
									{
										alt16 = 3;
									}
									else if ((LA16_6==12))
									{
										alt16 = 4;
									}


								}


							}


						}


					}


					}
					break;
				case 21:
					{
					int LA16_2 = input.LA(2);

					if ((LA16_2==16))
					{
						int LA16_3 = input.LA(3);

						if ((LA16_3==19))
						{
							alt16 = 2;
						}
						else if ((LA16_3==NAME))
						{
							int LA16_4 = input.LA(4);

							if ((LA16_4==SPACE))
							{
								int LA16_5 = input.LA(5);

								if ((LA16_5==NAME))
								{
									int LA16_6 = input.LA(6);

									if ((LA16_6==17))
									{
										alt16 = 3;
									}
									else if ((LA16_6==12))
									{
										alt16 = 4;
									}


								}


							}


						}


					}


					}
					break;
				case 20:
					{
					int LA16_2 = input.LA(2);

					if ((LA16_2==16))
					{
						int LA16_3 = input.LA(3);

						if ((LA16_3==19))
						{
							alt16 = 2;
						}
						else if ((LA16_3==NAME))
						{
							int LA16_4 = input.LA(4);

							if ((LA16_4==SPACE))
							{
								int LA16_5 = input.LA(5);

								if ((LA16_5==NAME))
								{
									int LA16_6 = input.LA(6);

									if ((LA16_6==17))
									{
										alt16 = 3;
									}
									else if ((LA16_6==12))
									{
										alt16 = 4;
									}


								}


							}


						}


					}


					}
					break;
				case 19:
					{
					alt16 = 2;
					}
					break;
				case NAME:
					{
					int LA16_2 = input.LA(2);

					if ((LA16_2==SPACE))
					{
						int LA16_3 = input.LA(3);

						if ((LA16_3==NAME))
						{
							int LA16_4 = input.LA(4);

							if ((LA16_4==17))
							{
								alt16 = 3;
							}
							else if ((LA16_4==12))
							{
								alt16 = 4;
							}


						}


					}


					}
					break;
				}

				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// CSharpCode.g:205:5: using_namespaces
					{
					DebugLocation(205, 5);
					PushFollow(Follow._using_namespaces_in_cpp_code1076);
					using_namespaces6=using_namespaces();
					PopFollow();

					DebugLocation(206, 5);

					    	result.UsingNamespaces.Add(using_namespaces6);
					    

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// CSharpCode.g:209:7: class
					{
					DebugLocation(209, 7);
					PushFollow(Follow._class_in_cpp_code1090);
					class7=@class();
					PopFollow();

					DebugLocation(210, 5);

					    	result.Classes.Add(class7);
					    

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// CSharpCode.g:213:7: variable
					{
					DebugLocation(213, 7);
					PushFollow(Follow._variable_in_cpp_code1104);
					variable8=variable();
					PopFollow();

					DebugLocation(214, 5);

					    	result.GlobalVariables.Add(variable8);
					    

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// CSharpCode.g:217:7: function
					{
					DebugLocation(217, 7);
					PushFollow(Follow._function_in_cpp_code1118);
					function9=function();
					PopFollow();

					DebugLocation(218, 5);

					    	result.GlobalFunctions.Add(function9);
					    

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("cpp_code", 11);
			LeaveRule("cpp_code", 11);
			LeaveRule_cpp_code();
	    }
	 	DebugLocation(222, 4);
		} finally { DebugExitRule(GrammarFileName, "cpp_code"); }
		return result;

	}
	// $ANTLR end "cpp_code"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_parse() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_parse() {}
	// $ANTLR start "parse"
	// CSharpCode.g:224:8: public parse returns [CSharpCode result] : cpp_code EOF ;
	[GrammarRule("parse")]
	public CSharpCode parse()
	{
		EnterRule_parse();
		EnterRule("parse", 12);
		TraceIn("parse", 12);
	    CSharpCode result = default(CSharpCode);


	    CSharpCode cpp_code10 = default(CSharpCode);

		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(224, 3);
		try
		{
			// CSharpCode.g:225:3: ( cpp_code EOF )
			DebugEnterAlt(1);
			// CSharpCode.g:225:6: cpp_code EOF
			{
			DebugLocation(225, 6);
			PushFollow(Follow._cpp_code_in_parse1157);
			cpp_code10=cpp_code();
			PopFollow();

			DebugLocation(225, 15);
			Match(input,EOF,Follow._EOF_in_parse1159); 
			DebugLocation(226, 3);

			  	result = cpp_code10;
			  

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parse", 12);
			LeaveRule("parse", 12);
			LeaveRule_parse();
	    }
	 	DebugLocation(228, 3);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return result;

	}
	// $ANTLR end "parse"
	#endregion Rules


	#region DFA
	private DFA9 dfa9;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa9 = new DFA9( this );
	}

	private class DFA9 : DFA
	{
		private const string DFA9_eotS =
			"\x5C\xFFFF";
		private const string DFA9_eofS =
			"\x1\xFFFF\x1\x8\x1\xFFFF\x1\x2\x7\xFFFF\x1\x8\x11\xFFFF\x1\x8\x2\xFFFF"+
			"\x1\x8\x4\xFFFF\x1\x2\x9\xFFFF\x2\x8\x3\xFFFF\x1\x8\xA\xFFFF\x1\x8\x1C"+
			"\xFFFF";
		private const string DFA9_minS =
			"\x2\x4\x1\xFFFF\x5\x4\x1\xFFFF\x2C\x4\x1\xFFFF\xA\x4\x1\xFFFF\xB\x4\x1"+
			"\xFFFF\xF\x4";
		private const string DFA9_maxS =
			"\x2\x19\x1\xFFFF\x5\x19\x1\xFFFF\x2C\x19\x1\xFFFF\xA\x19\x1\xFFFF\xB"+
			"\x19\x1\xFFFF\xF\x19";
		private const string DFA9_acceptS =
			"\x2\xFFFF\x1\x1\x5\xFFFF\x1\x2\x2C\xFFFF\x1\x2\xA\xFFFF\x1\x2\xB\xFFFF"+
			"\x1\x2\xF\xFFFF";
		private const string DFA9_specialS =
			"\x5C\xFFFF}>";
		private static readonly string[] DFA9_transitionS =
			{
				"\x15\x2\x1\x1",
				"\x4\x2\x1\x7\xA\x2\x1\xA\x1\x6\x1\x5\x1\x4\x1\x9\x1\x2\x1\x3",
				"",
				"\xD\x2\x1\xB\x8\x2",
				"\xC\x2\x1\xC\x9\x2",
				"\xC\x2\x1\xD\x9\x2",
				"\xC\x2\x1\xE\x9\x2",
				"\x5\x2\x1\xF\x10\x2",
				"",
				"\x5\x2\x1\x10\x10\x2",
				"\x4\x2\x1\x11\x11\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x1\x14\x1\x13\x1\x12\x1\x9\x2\x2",
				"\x4\x2\x1\x7\xA\x2\x1\xA\x6\x2",
				"\x4\x2\x1\x7\xA\x2\x1\xA\x6\x2",
				"\x4\x2\x1\x7\xA\x2\x1\xA\x6\x2",
				"\x4\x2\x1\x16\x11\x2",
				"\x4\x2\x1\x17\x11\x2",
				"\x14\x2\x1\x18\x1\x2",
				"\xC\x2\x1\x19\x9\x2",
				"\xC\x2\x1\x1A\x9\x2",
				"\xC\x2\x1\x1B\x9\x2",
				"\x5\x2\x1\x1C\x10\x2",
				"\x8\x2\x1\x1E\x4\x2\x1\x1D\x8\x2",
				"\xB\x2\x1\x1F\x1\x2\x1\x20\x8\x2",
				"\x4\x2\x1\x24\xB\x2\x1\x23\x1\x22\x1\x21\x2\x2\x1\x25",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x6\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x6\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x6\x2",
				"\x4\x2\x1\x26\x11\x2",
				"\x4\x2\x1\x7\xA\x2\x1\xA\x1\x6\x1\x5\x1\x4\x1\x9\x1\x2\x1\x3",
				"\x4\x2\x1\x28\x1\x27\x3\x2\x1\x29\xC\x2",
				"\x4\x2\x1\x2A\x11\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x1\x14\x1\x13\x1\x12\x1\x9\x2\x2",
				"\xC\x2\x1\x2B\x9\x2",
				"\xC\x2\x1\x2C\x9\x2",
				"\xC\x2\x1\x2D\x9\x2",
				"\x5\x2\x1\x2E\x10\x2",
				"\xD\x2\x1\x2F\x8\x2",
				"\x8\x2\x1\x31\x4\x2\x1\x30\x8\x2",
				"\x4\x2\x1\x28\x1\x32\x3\x2\x1\x29\xC\x2",
				"\x5\x2\x1\x33\x10\x2",
				"\xD\x2\x1\x34\x6\x2\x1\x35\x1\x2",
				"\xB\x2\x1\x1F\x1\x2\x1\x20\x8\x2",
				"\x4\x2\x1\x24\x11\x2",
				"\x4\x2\x1\x24\x11\x2",
				"\x4\x2\x1\x24\x11\x2",
				"\x4\x2\x1\x36\x11\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x1\x14\x1\x13\x1\x12\x1\x9\x2\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x1\x14\x1\x13\x1\x12\x1\x9\x2\x2",
				"\x4\x2\x1\x38\x1\x37\x3\x2\x1\x39\xC\x2",
				"\x9\x2\x1\x29\xC\x2",
				"\x4\x2\x1\x3A\x11\x2",
				"\x4\x2\x1\x7\xA\x2\x1\xA\x1\x6\x1\x5\x1\x4\x1\x9\x1\x2\x1\x3",
				"",
				"\x8\x2\x1\x3C\x4\x2\x1\x3B\x8\x2",
				"\x4\x2\x1\x38\x1\x3D\x3\x2\x1\x39\xC\x2",
				"\x5\x2\x1\x3E\x10\x2",
				"\xD\x2\x1\x3F\x6\x2\x1\x40\x1\x2",
				"\x5\x2\x1\x41\x3\x2\x1\x29\x1\x42\xB\x2",
				"\x4\x2\x1\x24\xB\x2\x1\x23\x1\x22\x1\x21\x2\x2\x1\x25",
				"\x4\x2\x1\x44\x1\x43\x3\x2\x1\x45\xC\x2",
				"\x9\x2\x1\x39\xC\x2",
				"\x4\x2\x1\x46\x11\x2",
				"\x4\x2\x1\x15\xA\x2\x1\xA\x1\x14\x1\x13\x1\x12\x1\x9\x2\x2",
				"",
				"\x9\x2\x1\x29\x1\x42\xB\x2",
				"\x4\x2\x1\x48\x1\x47\x10\x2",
				"\x4\x2\x1\x44\x1\x49\x3\x2\x1\x45\xC\x2",
				"\x5\x2\x1\x4A\x10\x2",
				"\xD\x2\x1\x4B\x6\x2\x1\x4C\x1\x2",
				"\x5\x2\x1\x4D\x3\x2\x1\x39\x1\x4E\xB\x2",
				"\x4\x2\x1\x48\x11\x2",
				"\x5\x2\x1\x4F\x10\x2",
				"\x9\x2\x1\x45\xC\x2",
				"\x4\x2\x1\x50\x11\x2",
				"\x4\x2\x1\x24\xB\x2\x1\x23\x1\x22\x1\x21\x2\x2\x1\x25",
				"",
				"\x9\x2\x1\x39\x1\x4E\xB\x2",
				"\x4\x2\x1\x52\x1\x51\x10\x2",
				"\x4\x2\x1\x53\x11\x2",
				"\x5\x2\x1\x54\x3\x2\x1\x45\x1\x55\xB\x2",
				"\x4\x2\x1\x52\x11\x2",
				"\x5\x2\x1\x56\x10\x2",
				"\x5\x2\x1\x41\x3\x2\x1\x29\x1\x42\xB\x2",
				"\x9\x2\x1\x45\x1\x55\xB\x2",
				"\x4\x2\x1\x58\x1\x57\x10\x2",
				"\x4\x2\x1\x59\x11\x2",
				"\x4\x2\x1\x58\x11\x2",
				"\x5\x2\x1\x5A\x10\x2",
				"\x5\x2\x1\x4D\x3\x2\x1\x39\x1\x4E\xB\x2",
				"\x4\x2\x1\x5B\x11\x2",
				"\x5\x2\x1\x54\x3\x2\x1\x45\x1\x55\xB\x2"
			};

		private static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
		private static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
		private static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
		private static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
		private static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
		private static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
		private static readonly short[][] DFA9_transition;

		static DFA9()
		{
			int numStates = DFA9_transitionS.Length;
			DFA9_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
			}
		}

		public DFA9( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 9;
			this.eot = DFA9_eot;
			this.eof = DFA9_eof;
			this.min = DFA9_min;
			this.max = DFA9_max;
			this.accept = DFA9_accept;
			this.special = DFA9_special;
			this.transition = DFA9_transition;
		}

		public override string Description { get { return "()* loopback of 157:9: ( options {greedy=false; } : . )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _NAME_in_using_namespace352 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_using_namespaces385 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _SPACE_in_using_namespaces387 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _using_namespace_in_using_namespaces394 = new BitSet(new ulong[]{0x28000UL});
		public static readonly BitSet _15_in_using_namespaces408 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _using_namespace_in_using_namespaces415 = new BitSet(new ulong[]{0x28000UL});
		public static readonly BitSet _17_in_using_namespaces431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _22_in_access_type454 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_access_type456 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_access_type471 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_access_type473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _20_in_access_type488 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_access_type490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_variable_value567 = new BitSet(new ulong[]{0x3FDFFF0UL});
		public static readonly BitSet _17_in_variable_value577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _access_type_in_variable619 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NAME_in_variable627 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _SPACE_in_variable630 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NAME_in_variable637 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_variable640 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAME_in_parameter689 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _SPACE_in_parameter692 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NAME_in_parameter699 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_parameters749 = new BitSet(new ulong[]{0x4202UL});
		public static readonly BitSet _SPACE_in_parameters764 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _14_in_parameters768 = new BitSet(new ulong[]{0x300UL});
		public static readonly BitSet _SPACE_in_parameters770 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _parameter_in_parameters777 = new BitSet(new ulong[]{0x4202UL});
		public static readonly BitSet _24_in_function_value826 = new BitSet(new ulong[]{0x3FFFFF0UL});
		public static readonly BitSet _25_in_function_value844 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _access_type_in_function877 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NAME_in_function885 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _SPACE_in_function888 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NAME_in_function895 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_function898 = new BitSet(new ulong[]{0x2300UL});
		public static readonly BitSet _SPACE_in_function900 = new BitSet(new ulong[]{0x2300UL});
		public static readonly BitSet _parameters_in_function903 = new BitSet(new ulong[]{0x2200UL});
		public static readonly BitSet _SPACE_in_function905 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_function908 = new BitSet(new ulong[]{0x1020000UL});
		public static readonly BitSet _17_in_function911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_value_in_function915 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _access_type_in_class959 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_class962 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NAME_in_class964 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _24_in_class976 = new BitSet(new ulong[]{0x2700100UL});
		public static readonly BitSet _variable_in_class988 = new BitSet(new ulong[]{0x2700100UL});
		public static readonly BitSet _function_in_class1002 = new BitSet(new ulong[]{0x2700100UL});
		public static readonly BitSet _25_in_class1026 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_class1028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _using_namespaces_in_cpp_code1076 = new BitSet(new ulong[]{0xF80102UL});
		public static readonly BitSet _class_in_cpp_code1090 = new BitSet(new ulong[]{0xF80102UL});
		public static readonly BitSet _variable_in_cpp_code1104 = new BitSet(new ulong[]{0xF80102UL});
		public static readonly BitSet _function_in_cpp_code1118 = new BitSet(new ulong[]{0xF80102UL});
		public static readonly BitSet _cpp_code_in_parse1157 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_parse1159 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Gplusnasite.CSharpParser 
